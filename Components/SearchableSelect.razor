@using Microsoft.AspNetCore.Components.Forms

<div class="input-group mb-3">
	@*TODO - Set the value of this to reflect the currently selected value*@
	<InputText
		@bind-Value="SearchTerm"
		@oninput="(e) => DoSearch(e.Value?.ToString() ?? string.Empty)"
		placeholder="@Placeholder" aria-label="@Placeholder" aria-describedby="@($"{Id}-btn")" class="form-control" />
	<Button Color="ButtonColor.Dark" id="@($"{Id}-btn")">
		<Icon Name=IconName.CaretDownFill />
	</Button>
</div>

@*TODO - Make this the options you can arrow through or click to pick a suggestion.*@
<div class="row">
	@if(_CancelableSearch.Exception != null)
	{
		<div class="col">
			<Alert>@_CancelableSearch.Exception.Message</Alert>
		</div>
	}
	else if(_CancelableSearch.Searching)
	{
		<!--- draw a spinner--->
		<div class="col">
			Spinner Goes Here
		</div>
	}
	else
	{
		@if(Options.Count() > 0)
		{
			<div class="col">
				Matches:
				<ul>
				@foreach(var option in Options)
				{
					<li>
						@option.Name<br/>
						<span style="font-size: smaller;">@option.ShortDescription</span>
					</li>
				}
				</ul>
			</div>
		}
		else
		{
			<div class="col">
				<em>No Results.</em>
			</div>
		}
	}
</div>

@code
{
	[Parameter]
	[EditorRequired]
	public Noun? Value { get; set; }

	[Parameter]
	public EventCallback<Noun?> ValueChanged { get; set; }
	
	[Parameter]
	[EditorRequired]
	public string? Id { get; set; }

	[Parameter]
	[EditorRequired]
	public Func<string, Task<IEnumerable<Noun>>> Search { get; set; } = default!;

	[Parameter]
	public string Placeholder { get; set; } = "Search";

	private string SearchTerm { get; set; } = string.Empty;
	private CancelableSearch _CancelableSearch = new CancelableSearch();

	private IEnumerable<Noun> Options = new List<Noun>();

	
	protected override async Task OnParametersSetAsync()
	{
		if(Search != null)
			await DoSearch(SearchTerm);
		
		await base.OnParametersSetAsync();
	}

	private void KeyUp()
	{
		Console.WriteLine($"\n\tFrom KeyUp() SearchTerm: {SearchTerm}");
	}

	#region Search
	private class CancelableSearch
	{
		public Task? Task { get; set; }
		public bool Searching => Task != null && !EolStatuses.Contains(Task!.Status);
		public CancellationTokenSource? TokenSource { get; set; }
		public Exception? Exception;

		public static List<TaskStatus> EolStatuses = new List<TaskStatus> { TaskStatus.RanToCompletion, TaskStatus.Canceled };

		public void CancelSearch()
		{
			if(TokenSource != null)
			{
				var problem = EolStatuses.Any(st => st == Task?.Status);
				if (!problem)
				{
					TokenSource.Cancel();
				}
			}
		}


	}

	protected async Task DoSearch(string value)
	{
		Console.WriteLine(value);
		if(SearchTerm != value)
		{
			// YOU ARE HERE
			// TODO: Use a cancellation token to wait for user to finish typting before querying the DB.
			
			// Cancel any other running search
			_CancelableSearch.CancelSearch();

			// Make a cancelable request to the API and process the response.
			var ts = new CancellationTokenSource();
			_CancelableSearch = new CancelableSearch
			{
				TokenSource = ts,
				Task = Task.Run(async () =>
				{
					// Wait for the user to stop typing before querying DB.
					await Task.Delay(500);
					
					Console.Write($"\n\tInvoking Search({value})... ");
					var results = await Search(value);

					// If our Token didn't get canceled query the DB.
					if (ts.Token.IsCancellationRequested == false)
					{
						try
						{
							if(results == null)
							{
								throw new Exception($"No Results for term \"{value}\"");
							}

							Console.WriteLine($" got {results.Count()}");
							Options = results;
							SearchTerm = value;//Update the value bound to the search input.
						}
						catch(Exception ex)
						{
							_CancelableSearch.Exception = ex;
						}
					}
				}, ts.Token)
			};

			await _CancelableSearch.Task;
		}
	}

	
	#endregion
}